import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { findOvercountingHint } from '../src/logic/techniques/overcounting';
import { computeMinStars, computeMaxStars } from '../src/logic/helpers';
import type { PuzzleState, PuzzleDef, CellState, Coords } from '../src/types/puzzle';

// Helper to create a puzzle state
function createPuzzleState(size: number, starsPerUnit: number, regions: number[][], cells: CellState[][]): PuzzleState {
  const def: PuzzleDef = { size, starsPerUnit, regions };
  return { def, cells };
}

// Arbitrary generator for valid cell coordinates
const coordsArb = fc.record({
  row: fc.integer({ min: 0, max: 9 }),
  col: fc.integer({ min: 0, max: 9 }),
});

// Generator for a list of unique coordinates
const uniqueCoordsArb = fc.array(coordsArb, { minLength: 1, maxLength: 20 }).map((coords) => {
  const seen = new Set<string>();
  const unique: Coords[] = [];
  for (const coord of coords) {
    const key = `${coord.row},${coord.col}`;
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(coord);
    }
  }
  return unique;
});

describe('Overcounting - Property Tests', () => {
  /**
   * Property 15: Overcounting respects 2×2 constraints
   * Validates: Requirements 8.2
   * 
   * For any composite shape, the computed maximum star count should never
   * be less than the minimum required stars considering 2×2 block constraints.
   */
  it('Property 15: maximum stars never less than minimum stars for any shape', () => {
    fc.assert(
      fc.property(uniqueCoordsArb, (cells) => {
        // Create a simple puzzle state with empty cells
        const size = 10;
        const starsPerUnit = 2;
        const regions: number[][] = [];
        const cellStates: CellState[][] = [];
        
        for (let r = 0; r < size; r++) {
          const regionRow: number[] = [];
          const cellRow: CellState[] = [];
          for (let c = 0; c < size; c++) {
            regionRow.push(Math.floor(r / 2) * 5 + Math.floor(c / 2) + 1);
            cellRow.push('empty');
          }
          regions.push(regionRow);
          cellStates.push(cellRow);
        }
        
        const state = createPuzzleState(size, starsPerUnit, regions, cellStates);
        
        // Compute min and max for the given cells
        const minStars = computeMinStars(state, cells);
        const maxStars = computeMaxStars(state, cells);
        
        // Property: max should never be less than min
        expect(maxStars).toBeGreaterThanOrEqual(minStars);
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property 16: Overcounting hints include shape highlights
   * Validates: Requirements 8.4
   * 
   * For any hint generated by the overcounting technique, the hint's
   * highlights should include all regions involved in the composite shape.
   */
  it('Property 16: overcounting hints include region highlights', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 0, max: 9 }),
        fc.integer({ min: 1, max: 10 }),
        fc.array(fc.record({ row: fc.integer({ min: 0, max: 9 }), col: fc.integer({ min: 0, max: 9 }) }), { minLength: 0, maxLength: 15 }),
        (targetRow, targetRegion, starPositions) => {
          // Create a puzzle state where overcounting might apply
          const size = 10;
          const starsPerUnit = 2;
          const regions: number[][] = [];
          const cells: CellState[][] = [];
          
          // Create regions - simple layout where each 2x5 block is a region
          for (let r = 0; r < size; r++) {
            const regionRow: number[] = [];
            const cellRow: CellState[] = [];
            for (let c = 0; c < size; c++) {
              regionRow.push(Math.floor(r / 2) * 5 + Math.floor(c / 2) + 1);
              cellRow.push('empty');
            }
            regions.push(regionRow);
            cells.push(cellRow);
          }
          
          // Place stars at random positions to create scenarios where overcounting might apply
          const placedStars = new Set<string>();
          for (const pos of starPositions) {
            const key = `${pos.row},${pos.col}`;
            if (!placedStars.has(key)) {
              // Check if placing a star here would violate constraints
              let canPlace = true;
              
              // Check adjacency
              for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                  if (dr === 0 && dc === 0) continue;
                  const nr = pos.row + dr;
                  const nc = pos.col + dc;
                  if (nr >= 0 && nr < size && nc >= 0 && nc < size) {
                    if (cells[nr][nc] === 'star') {
                      canPlace = false;
                      break;
                    }
                  }
                }
                if (!canPlace) break;
              }
              
              if (canPlace) {
                cells[pos.row][pos.col] = 'star';
                placedStars.add(key);
              }
            }
          }
          
          const state = createPuzzleState(size, starsPerUnit, regions, cells);
          const hint = findOvercountingHint(state);
          
          // If a hint is found, it must have proper highlights
          if (hint) {
            expect(hint.highlights).toBeDefined();
            
            // Must have either rows or cols (the units involved)
            const hasRowOrCol = (hint.highlights?.rows && hint.highlights.rows.length > 0) ||
                               (hint.highlights?.cols && hint.highlights.cols.length > 0);
            expect(hasRowOrCol).toBe(true);
            
            // Must have regions (the composite shape involves regions)
            expect(hint.highlights?.regions).toBeDefined();
            expect(hint.highlights?.regions!.length).toBeGreaterThan(0);
            
            // Must have cells (the result cells that must be crosses)
            expect(hint.highlights?.cells).toBeDefined();
            expect(hint.highlights?.cells!.length).toBeGreaterThan(0);
          }
        }
      ),
      { numRuns: 100 }
    );
  });

  it('overcounting finds forced crosses when maximum is reached', () => {
    // Create a specific scenario where overcounting applies
    const size = 10;
    const starsPerUnit = 2;
    const regions: number[][] = [];
    const cells: CellState[][] = [];
    
    // Create a simple region layout where each column is a region
    for (let r = 0; r < size; r++) {
      const regionRow: number[] = [];
      const cellRow: CellState[] = [];
      for (let c = 0; c < size; c++) {
        regionRow.push(c + 1);
        cellRow.push('empty');
      }
      regions.push(regionRow);
      cells.push(cellRow);
    }
    
    // Create a scenario where 2×2 constraints limit the maximum
    // Place stars in a pattern that creates 2×2 blocks
    cells[0][0] = 'star';
    cells[0][2] = 'star';
    cells[2][0] = 'star';
    cells[2][2] = 'star';
    
    // The 2×2 block at (0,0)-(1,1) has a star at (0,0)
    // So cells (0,1), (1,0), (1,1) cannot be stars
    // Similarly for other blocks
    
    const state = createPuzzleState(size, starsPerUnit, regions, cells);
    const hint = findOvercountingHint(state);
    
    // Should find forced crosses due to 2×2 constraints
    if (hint) {
      expect(hint.kind).toBe('place-cross');
      expect(hint.technique).toBe('overcounting');
      expect(hint.resultCells.length).toBeGreaterThan(0);
    }
  });

  it('marks cells outside fully covered rows when the number of regions matches', () => {
    const size = 6;
    const starsPerUnit = 1;

    const regions: number[][] = [
      [1, 1, 2, 2, 3, 3],
      [1, 1, 2, 2, 3, 3],
      [1, 1, 2, 2, 3, 3],
      [1, 4, 5, 5, 6, 6],
      [1, 4, 5, 5, 6, 6],
      [1, 4, 5, 5, 6, 6],
    ];

    const cells: CellState[][] = Array.from({ length: size }, () =>
      Array.from({ length: size }, () => 'empty' as CellState)
    );

    const state = createPuzzleState(size, starsPerUnit, regions, cells);
    const hint = findOvercountingHint(state);

    expect(hint?.technique).toBe('overcounting');
    expect(hint?.kind).toBe('place-cross');
    expect(hint?.resultCells).toEqual(
      expect.arrayContaining([
        { row: 3, col: 0 },
        { row: 4, col: 0 },
        { row: 5, col: 0 },
      ])
    );
    expect(hint?.highlights?.rows).toEqual(expect.arrayContaining([0, 1, 2]));
    expect(hint?.highlights?.regions).toEqual(expect.arrayContaining([1, 2, 3]));
  });
});
